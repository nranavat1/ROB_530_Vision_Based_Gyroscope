# -*- coding: utf-8 -*-
"""Copy of Best_RGBD_OF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1030x4m2LR7Hjsz7mvqF2wKRExa94KINs

# Example Usage

## 0. Setup
### Clone the Github Repository
First we need to clone the repository so we have access to the original code. Additionally, we will install all the required dependency packages.
"""

# Commented out IPython magic to ensure Python compatibility.
! git clone https://github.com/nranavat1/ROB_530_Vision_Based_Gyroscope.git
# %cd ROB_530_Vision_Based_Gyroscope

# Commented out IPython magic to ensure Python compatibility.
!python3 -m venv venv
!source venv/bin/activate
# %pip install -r requirements.txt

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2

"""


### Import the necessary packages.


"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
import os
import time
import math
import gtsam

import sys
sys.path.append('/content/ROB_530_Vision_Based_Gyroscope/src')

"""### Get the Data
For this, please have the data files ready, instructions on the README.md

"""

!tar -xzvf ./data/rgbd_dataset_freiburg1_xyz.tgz

# Colab ▶ Cell 1
!pip install -q condacolab
import condacolab
condacolab.install()

# Colab ▶ Cell 2  (after the runtime comes back up)
!mamba install -y -c conda-forge gtsam

TUM_DATASET_PATH = './rgbd_dataset_freiburg1_xyz'
MIN_FEATURES_FOR_PNP = 5    # Minimum number of features required for PnP
MIN_FEATURES_REDETECT = 50   # Threshold to trigger feature point replenishment
VISUALIZE_EVERY_N_FRAMES = 10 # Display image every N frames (0 for no display)
MAX_FRAMES_TO_PROCESS = 0   # Set the maximum number of frames to process (0 to process all associated frames)

# --- Parameters for feature detection and tracking ---
feature_params = dict(maxCorners=100,     # Maximum number of corners to detect
                      qualityLevel=0.3,   # Corner quality threshold (0-1), higher is stronger
                      minDistance=7,      # Minimum distance between corners
                      blockSize=7)        # Block size for computing corners

lk_params = dict(winSize=(15, 15),        # Window size for optical flow (LK method)
                 maxLevel=2,              # Number of pyramid levels (0 = only original image)
                 criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))  # Termination criteria


# Camera intrinsics (example from freiburg1/xyz) - check your dataset for real values!
fx = 517.3
fy = 516.5
cx = 318.6
cy = 255.3
# For simplicity, distortion is not considered here
camera_matrix = np.array([[fx, 0, cx],
                          [0, fy, cy],
                          [0, 0, 1]])

"""# **0. Preparation: Test your Dataset**"""

from utils import associate_frames, load_image_pair
from google.colab.patches import cv2_imshow  # Important: for image display in Colab


# --- Parameters (must be set for your specific TUM sequence!) ---
DEPTH_SCALE = 5000.0  # Typical scale for TUM freiburg sequences (1, 2, 3)

dist_coeffs = np.zeros((4, 1))  # Assume no distortion

rgb_list = os.path.join(TUM_DATASET_PATH, 'rgb.txt')
depth_list = os.path.join(TUM_DATASET_PATH, 'depth.txt')

print(f"Searching for data in: {TUM_DATASET_PATH}")
print(f"Using depth scale: {DEPTH_SCALE}")
print(f"Camera intrinsics:\n{camera_matrix}")

if not os.path.exists(rgb_list) or not os.path.exists(depth_list):
    print(f"Error: Cannot find rgb.txt or depth.txt in {TUM_DATASET_PATH}")
    exit()

frame_associations = associate_frames(rgb_list, depth_list)

if not frame_associations:
    print("Error: No associated RGB and Depth frames. Check path and timestamps.")
    exit()

print(f"Successfully found {len(frame_associations)} associated frame pairs.")

if len(frame_associations) > 0:
    first_rgb_stamp, first_rgb_file, first_depth_stamp, first_depth_file = frame_associations[0]
    print(f"\nLoading the first image pair:")
    print(f"  RGB:   Timestamp {first_rgb_stamp}, File {first_rgb_file}")
    print(f"  Depth: Timestamp {first_depth_stamp}, File {first_depth_file}")

    bgr_img, depth_img = load_image_pair(first_rgb_file, first_depth_file, TUM_DATASET_PATH, depth_scale=DEPTH_SCALE)

    if bgr_img is not None and depth_img is not None:
        print(f"  Successfully loaded RGB image, shape: {bgr_img.shape}")
        print(f"  Successfully loaded Depth image, shape: {depth_img.shape}, dtype: {depth_img.dtype}")
        # Convert the first frame to grayscale
        gray_prev = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
        print(f"First frame image size: {gray_prev.shape}")

        # Detect initial feature points in the first frame
        p0 = cv2.goodFeaturesToTrack(gray_prev, mask = None, **feature_params)
        if p0 is None or len(p0) < MIN_FEATURES_FOR_PNP:
            raise ValueError(f"Insufficient initial feature points detected in the first frame ({len(p0) if p0 is not None else 0}).")
        print(f"Detected {len(p0)} initial feature points.")
        h, w = depth_img.shape
        center_depth = depth_img[h//2, w//2]
        if not np.isnan(center_depth) and center_depth > 0:
            print(f"  Center pixel ({h//2}, {w//2}) depth: {center_depth:.3f} meters (raw: {int(center_depth * DEPTH_SCALE)})")
        else:
            print(f"  Center pixel ({h//2}, {w//2}) has invalid or zero depth.")

        cv2_imshow(bgr_img)
        depth_display = depth_img.copy()
        depth_display[np.isnan(depth_display)] = 0
        depth_display = cv2.normalize(depth_display, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)
        cv2_imshow(depth_display)
    else:
        print("Failed to load the first image pair.")
else:
    print("No associated frames found.")

"""# **0.5. Optical Flow and PnP Test**"""

from OpticalFlowUtils import detectFeaturePoints, createMask, opticalFlowTracking


bgr_prev, gray_prev, p0 = detectFeaturePoints(frame_associations, TUM_DATASET_PATH, feature_params)
opticalFlowTracking(frame_associations, bgr_prev, gray_prev, p0, TUM_DATASET_PATH, feature_params, lk_params)

"""## 1. Optical Flow and PnP

This code segment handles the visualization and state update steps of a visual odometry pipeline. It periodically displays tracking results by drawing feature point trajectories and overlays frame tracking stats. Afterward, it updates the grayscale image, depth map, and feature points for the next iteration, including re-detecting new features if the current number drops below a threshold.



"""

import cv2
import numpy as np
from FeatureTracker import feature_track


# --- PnP RANSAC Parameters (solvePnPRansac) ---
pnp_ransac_params = dict(
    iterationsCount=150,     # Number of RANSAC iterations 100
    reprojectionError=1.8,   # RANSAC inlier threshold (pixels) - !! May need tuning !! 2.0
    confidence=0.99,         # RANSAC confidence level
    flags=cv2.SOLVEPNP_ITERATIVE # PnP solver flags
)

relative_poess = feature_track(frame_associations, p0, gray_prev, bgr_prev, camera_matrix, TUM_DATASET_PATH, feature_params, lk_params, dist_coeffs, pnp_ransac_params, max_frames_to_process=MAX_FRAMES_TO_PROCESS, min_features_for_pnp=MIN_FEATURES_FOR_PNP, min_features_redetect=MIN_FEATURES_REDETECT, visualize_every_n_frames=VISUALIZE_EVERY_N_FRAMES)

"""# **3. Motion Estimation**"""



# from scipy.spatial.transform import Rotation as R_scipy

# output_lines = []
# t_global = T_world_current[0:3, 3]
# quat = R_scipy.from_matrix(T_world_current[0:3, 0:3]).as_quat()

# timestamp_curr = frame_associations[i][0]

# out_line = f"{timestamp_curr} {t_global[0]:.4f} {t_global[1]:.4f} {t_global[2]:.4f} {quat[0]:.4f} {quat[1]:.4f} {quat[2]:.4f} {quat[3]:.4f}"
# output_lines.append(out_line)
gt_file_path = os.path.join(TUM_DATASET_PATH, 'groundtruth.txt')
gt_data = np.loadtxt(gt_file_path)
gt_timestamps = gt_data[:, 0]

new_output_lines = []
for i, line in enumerate(output_lines):

    if i < len(gt_timestamps):
        timestamp = gt_timestamps[i]
    else:

        timestamp = gt_timestamps[-1]
    new_line = f"{timestamp} " + line
    new_output_lines.append(new_line)


with open("trajectory_output.txt", "w") as f:
    for line in new_output_lines:
        f.write(line + "\n")
print("Trajectory saved to trajectory_output.txt")

!pip install evo --upgrade

!evo_traj tum --ref "/content/drive/MyDrive/ROB 530 Mobile Robotics Final Project/project code/rgbd_dataset_freiburg1_rpy/groundtruth.txt" "/content/drive/MyDrive/ROB 530 Mobile Robotics Final Project/project code/trajectory_output.txt" --align --plot

!evo_traj tum \
  --ref "/content/drive/MyDrive/ROB 530 Mobile Robotics Final Project/project code/rgbd_dataset_freiburg1_xyz/groundtruth.txt" \
  "/content/drive/MyDrive/ROB 530 Mobile Robotics Final Project/project code/trajectory_output.txt" \
  --align --save_plot traj_result.png

"""**Test GTSAM**"""

# Colab ▶ Cell 3
import numpy as np
import gtsam
from gtsam import Pose3, Rot3, Point3
# simple smoke test
print("GTSAM imported, identity pose:", Pose3())

from gtsam import (
        Pose3, Rot3, Point3,
        PriorFactorPose3, BetweenFactorPose3,
        NonlinearFactorGraph, Values,
        noiseModel, GaussNewtonOptimizer, symbol
    )

import numpy as np
import math
import gtsam
from gtsam import (
    Pose3, Rot3, Point3,
    PriorFactorPose3, BetweenFactorPose3,
    NonlinearFactorGraph, Values,
    noiseModel, GaussNewtonOptimizer, symbol
)

def optimize_trajectory_with_gtsam(relative_poses):
    if not isinstance(relative_poses, list) or len(relative_poses) == 0:
        raise ValueError("`relative_poses` must be a non-empty list")

    # Build graph + initial values
    graph   = NonlinearFactorGraph()
    initial = Values()

    # Prior on pose0
    key0       = symbol('x', 0)
    prior_pose = Pose3()
    initial.insert(key0, prior_pose)
    prior_noise = noiseModel.Diagonal.Sigmas(np.array([1e-6]*6))
    graph.add(PriorFactorPose3(key0, prior_pose, prior_noise))

    # Add BetweenFactors by simple enumeration
    for idx, rel in enumerate(relative_poses):
        j = idx
        k = idx + 1
        key_prev = symbol('x', j)
        key_curr = symbol('x', k)

        R_ij = Rot3(rel['R'])
        t_ij = Point3(*rel['t'])
        odom = Pose3(R_ij, t_ij)

        prev_est = initial.atPose3(key_prev)
        initial.insert(key_curr, prev_est.compose(odom))

        odom_noise = noiseModel.Diagonal.Sigmas(np.array([0.1]*6))
        graph.add(BetweenFactorPose3(key_prev, key_curr, odom, odom_noise))

    # Optimize
    result = GaussNewtonOptimizer(graph, initial).optimize()

    # Extract trajectory_xyz & orientations_rpy
    trajectory_xyz   = []
    orientations_rpy = []
    for k in range(len(relative_poses) + 1):
        p = result.atPose3(symbol('x', k))
        trajectory_xyz.append(np.array([p.x(), p.y(), p.z()]))
        yaw, pitch, roll = p.rotation().ypr()
        orientations_rpy.append(np.array([roll, pitch, yaw]))

    return trajectory_xyz, orientations_rpy



trajectory_xyz, orientations_rpy = optimize_trajectory_with_gtsam(relative_poses)
print("trajectory_xyz =", trajectory_xyz)
# print("orientations_rpy =", orientations_rpy)

# --- 5. Visualize Trajectory ---
import numpy as np
import math
# Optional: for plotting
import matplotlib.pyplot as plt
from scipy.spatial.transform import Rotation as R_scipy


if len(trajectory_xyz) > 1:
    print("\nPlotting trajectory...")
    trajectory_xyz_np = np.array(trajectory_xyz)

    plt.style.use('seaborn-v0_8-whitegrid') # Use a nice plotting style

    # Plot X-Y trajectory (top-down view)
    plt.figure(figsize=(9, 7))
    plt.plot(trajectory_xyz_np[:, 0], trajectory_xyz_np[:, 1], '.-', markersize=4, linewidth=1.5, label='Estimated Trajectory (X-Y)')
    plt.scatter(trajectory_xyz_np[0, 0], trajectory_xyz_np[0, 1], marker='s', color='red', s=100, label='Start Point', zorder=5)
    plt.scatter(trajectory_xyz_np[-1, 0], trajectory_xyz_np[-1, 1], marker='*', color='lime', s=150, label='End Point', zorder=5)
    plt.xlabel("X Position (meters)")
    plt.ylabel("Y Position (meters)")
    plt.title("Estimated Camera Motion Trajectory (Top-Down View)")
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.axis('equal') # Ensure X and Y axis scales are equal
    plt.legend()
    plt.show()

    # Plot Z height variation
    plt.figure(figsize=(12, 4))
    # Construct the corresponding frame index list (including frame 0)
    frame_indices = [0] + [rp['frame_index'] for rp in relative_poses[:len(trajectory_xyz)-1]] # Ensure index count matches
    plt.plot(frame_indices, trajectory_xyz_np[:, 2], '.-', markersize=4, linewidth=1.5, color='purple', label='Z Height')
    plt.xlabel("Frame Index")
    plt.ylabel("Z Position (meters)")
    plt.title("Estimated Camera Height (Z-axis) Variation")
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.legend()
    plt.tight_layout()
    plt.show()

def hampel_filter(x, k=7, t0=3):
    x = np.array(x)
    L = len(x)
    new_x = x.copy()
    for i in range(k, L-k):
        window = x[i-k:i+k+1]
        med = np.median(window)
        mad = np.median(np.abs(window - med))
        if np.abs(x[i] - med) > t0 * mad:
            new_x[i] = med
    return new_x

pts = np.vstack(trajectory_xyz)
for dim in range(3):
    pts[:,dim] = hampel_filter(pts[:,dim], k=5, t0=3)
trajectory_xyz = [p for p in pts]
print("trajectory_xyz =", trajectory_xyz)

import numpy as np


pts = np.vstack(trajectory_xyz)


steps = np.linalg.norm(np.diff(pts, axis=0), axis=1)


MAX_STEP = 0.2


bad = np.where(steps > MAX_STEP)[0] + 1


mask = np.ones(len(pts), dtype=bool)
mask[bad] = False

trajectory_xyz = [p for i,p in enumerate(pts)      if mask[i]]
orientations_rpy = [r for i,r in enumerate(orientations_rpy) if mask[i]]
print("trajectory_xyz =", trajectory_xyz)

import numpy as np
import matplotlib.pyplot as plt

# 1) stack into an (N×3) array
pts = np.vstack(trajectory_xyz)   # original trajectory

# 2) detect big jumps
steps = np.linalg.norm(np.diff(pts, axis=0), axis=1)
thresh = steps.mean() + 3*steps.std()
outlier_idxs = np.where(steps > thresh)[0]  # step indices
# the actual “jump” happens from frame i to i+1
jump_frames = outlier_idxs + 1

# 3) make a copy and eliminate each jump by translating the tail
corrected = pts.copy()
for f in jump_frames:
    # compute the jump vector
    v = corrected[f] - corrected[f-1]
    # subtract it from all subsequent points
    corrected[f:] -= v

# 4) plot original vs “stitched” trajectory
plt.figure(figsize=(6,6))
plt.plot(pts[:,0],    pts[:,1],    'C1.-', alpha=0.3, label="original")
plt.plot(corrected[:,0], corrected[:,1], 'C0.-', label="stitched")
# mark where jumps were removed
plt.scatter(pts[jump_frames,0], pts[jump_frames,1],
            c='r', marker='x', label="jumps")
plt.axis('equal'); plt.grid(True)
plt.legend()
plt.xlabel("X"); plt.ylabel("Y")
plt.title("Jump‑corrected trajectory")
plt.show()

# 5) if you need to keep using trajectory_xyz and orientations_rpy,
#    simply overwrite:
trajectory_xyz    = [p for p in corrected]
# orientations_rpy unchanged (or you could interpolate if needed)

"""# **Optional: for XYZ Dataset Evaluation**"""

import numpy as np
import matplotlib.pyplot as plt
import os # Ensure the os module is imported

# --- Function: Load Ground Truth Poses ---
def load_ground_truth(gt_file):
    """Load ground truth file (format: timestamp tx ty tz qx qy qz qw)"""
    ground_truth = {} # Use a dictionary for convenient lookup by timestamp
    try:
        with open(gt_file, 'r') as f:
            for line in f:
                line = line.strip()
                # Skip empty or comment lines
                if not line or line.startswith('#'):
                    continue
                parts = line.split()
                # Ensure correct format (at least 8 fields)
                if len(parts) >= 8:
                    ts = float(parts[0])
                    # Extract XYZ coordinates
                    xyz = np.array([float(p) for p in parts[1:4]])
                    # (Optional) Extract quaternions (if comparing orientations later)
                    # quat = np.array([float(p) for p in parts[4:8]]) # qx, qy, qz, qw
                    ground_truth[ts] = {'xyz': xyz} # , 'quat': quat} # Storing only XYZ is also fine
                else:
                    print(f"Skipping malformed ground truth line: {line}")

    except FileNotFoundError:
        print(f"!! Error: Ground truth file not found: {gt_file} !!")
        return None
    except Exception as e:
        print(f"!! Error: Error reading ground truth file: {e} !!")
        return None

    if not ground_truth:
        print(f"Warning: Failed to load any ground truth poses from {os.path.basename(gt_file)}.")
    else:
        print(f"Loaded {len(ground_truth)} ground truth poses from {os.path.basename(gt_file)}.")
    return ground_truth

# --- Function: Associate Estimated Trajectory with Ground Truth ---
def associate_trajectory(estimated_xyz, estimated_timestamps, ground_truth_dict, max_diff_sec=0.02):
    """Associate estimated trajectory points with ground truth based on timestamps."""

    if not ground_truth_dict or not estimated_timestamps or len(estimated_xyz) != len(estimated_timestamps):
        print("Warning: Insufficient or mismatched input data, cannot perform association.")
        return [], [], [] # Return empty lists

    gt_timestamps = np.array(sorted(ground_truth_dict.keys()))

    matches = [] # Store matching results [(est_ts, gt_ts, est_xyz, gt_xyz)]

    gt_search_idx = 0 # Starting index for optimized search

    # Iterate through each estimated pose and its timestamp
    for i, est_ts in enumerate(estimated_timestamps):
        min_diff = float('inf')
        best_match_gt_ts = -1

        # Find the closest matching ground truth timestamp
        search_start = max(0, gt_search_idx - 5) # Start search near the last match
        j = search_start
        while j < len(gt_timestamps):
            gt_ts = gt_timestamps[j]
            diff = abs(est_ts - gt_ts)
            if diff < min_diff:
                min_diff = diff
                best_match_gt_ts = gt_ts
            # Optimization: Stop searching if the difference increases and exceeds the threshold, or if the gt timestamp is much greater than the est timestamp
            elif diff >= min_diff + max_diff_sec: break
            if gt_ts > est_ts + max_diff_sec * 2 and min_diff > max_diff_sec: break
            j += 1

        # If a sufficiently close match is found
        if min_diff < max_diff_sec and best_match_gt_ts != -1:
            matches.append((
                est_ts,
                best_match_gt_ts,
                estimated_xyz[i], # Current estimated XYZ
                ground_truth_dict[best_match_gt_ts]['xyz'] # Matching GT XYZ
            ))
            # Update the starting index for the next search
            gt_match_indices = np.where(gt_timestamps == best_match_gt_ts)[0]
            if len(gt_match_indices) > 0:
                gt_search_idx = gt_match_indices[0]

    if not matches:
        print("Warning: Failed to associate any estimated poses with ground truth. Check timestamps and max_diff_sec parameter.")
        return [], [], []

    # Decompose matching results into separate lists
    matched_est_ts, matched_gt_ts, matched_est_xyz, matched_gt_xyz = zip(*matches)

    print(f"Successfully associated {len(matches)} pairs of estimated and ground truth poses.")

    # Return NumPy arrays for subsequent calculations
    return np.array(matched_est_xyz), np.array(matched_gt_xyz), list(matched_est_ts)

# --- Function: Simple Translation Alignment ---
def align_translation(estimated_traj, ground_truth_traj):
    """Align estimated and ground truth trajectories by matching the first point."""
    if estimated_traj.shape[0] == 0 or ground_truth_traj.shape[0] == 0:
        print("Warning: Input trajectory is empty, cannot perform translation alignment.")
        return estimated_traj

    # Calculate the offset between the first matching points
    translation_offset = ground_truth_traj[0, :] - estimated_traj[0, :]
    # Apply this offset to the entire estimated trajectory
    aligned_traj = estimated_traj + translation_offset
    offset_str = np.array2string(translation_offset, precision=3, suppress_small=True)
    print(f"Applied translation alignment, offset: {offset_str}")
    return aligned_traj

# --- Function: Calculate Absolute Trajectory Error (ATE) RMSE ---
def calculate_ate_rmse(estimated_traj, ground_truth_traj):
    """Calculate the Root Mean Square Error of the ATE."""
    if estimated_traj.shape != ground_truth_traj.shape:
        # Theoretically, shapes should match after association, unless there's an association error
        print(f"Error: Trajectory shapes do not match for ATE calculation! Est: {estimated_traj.shape}, GT: {ground_truth_traj.shape}")
        min_len = min(estimated_traj.shape[0], ground_truth_traj.shape[0])
        if min_len == 0: return np.nan # Cannot calculate
        print(f"Will only use the first {min_len} points for calculation.")
        estimated_traj = estimated_traj[:min_len, :]
        ground_truth_traj = ground_truth_traj[:min_len, :]
        # raise ValueError("Trajectories for ATE calculation must have the same shape.")

    if estimated_traj.shape[0] == 0:
        print("Warning: No matching point pairs to calculate ATE.")
        return 0.0

    # Calculate the Euclidean distance (error) between each pair of points
    errors = np.linalg.norm(estimated_traj - ground_truth_traj, axis=1)
    # Calculate the Root Mean Square of the errors
    rmse = np.sqrt(np.mean(np.square(errors)))
    return rmse

# --- Main Comparison Logic ---
print("\n--- 5. Start Comparison with Ground Truth ---")

# Confirm that necessary variables exist
if 'trajectory_xyz' not in locals():
    print("!! Error: Variable 'trajectory_xyz' is not defined. Please run the code to calculate the trajectory first. !!")
elif 'frame_associations' not in locals():
    print("!! Error: Variable 'frame_associations' is not defined. !!")
elif 'TUM_DATASET_PATH' not in locals() or not os.path.isdir(TUM_DATASET_PATH):
    print(f"!! Error: 'TUM_DATASET_PATH' ({TUM_DATASET_PATH}) is invalid or not defined. !!")
else:
    # 1. Load Ground Truth
    gt_file_path = os.path.join(TUM_DATASET_PATH, 'groundtruth.txt')
    ground_truth_data = load_ground_truth(gt_file_path)

    # Ensure ground truth is loaded successfully and the estimated trajectory has points
    if ground_truth_data and len(trajectory_xyz) > 1:

        # 2. Get timestamps corresponding to the estimated trajectory
        # Assume trajectory_xyz[k] corresponds to frame_associations[k][0] (RGB timestamp)
        # Note: trajectory_xyz may be shorter than frame_associations by 1 (if the last relative pose wasn't calculated)
        num_est_poses = len(trajectory_xyz)
        if num_est_poses > len(frame_associations):
            print(f"Warning: Number of estimated trajectory points ({num_est_poses}) is greater than the number of associated frames ({len(frame_associations)}), truncating timestamps.")
            estimated_timestamps = [assoc[0] for assoc in frame_associations[:num_est_poses]]
        else:
            estimated_timestamps = [frame_associations[k][0] for k in range(num_est_poses)]

        estimated_xyz_np = np.array(trajectory_xyz) # Convert to NumPy array

        # 3. Associate Trajectories
        est_xyz_matched, gt_xyz_matched, common_timestamps = associate_trajectory(
            estimated_xyz_np,
            estimated_timestamps,
            ground_truth_data
        )

        # Ensure there are association results and at least 2 points for alignment
        if est_xyz_matched.shape[0] > 1:

            # 4. Align Trajectories (Simple Translation Alignment)
            # For sequences like freiburg1_xyz, which are primarily translational, this is often the first step.
            # If there's significant rotation, more complex SE(3) alignment might be needed.
            aligned_est_xyz = align_translation(est_xyz_matched, gt_xyz_matched)

            # 5. Calculate ATE RMSE
            ate_rmse = calculate_ate_rmse(aligned_est_xyz, gt_xyz_matched)
            print("\nComparison Results:")
            print(f"Absolute Trajectory Error (ATE) RMSE: {ate_rmse:.4f} meters")

            # 6. Visualize Comparison
            print("Plotting comparison trajectory graph...")
            plt.style.use('seaborn-v0_8-whitegrid')
            plt.figure(figsize=(9, 7))

            # Plot Ground Truth Trajectory (X-Y)
            plt.plot(gt_xyz_matched[:, 0], gt_xyz_matched[:, 1], '.-', color='blue', linewidth=1.5, markersize=4, label='Ground Truth Trajectory', alpha=0.8)

            # Plot Aligned Estimated Trajectory (X-Y)
            plt.plot(aligned_est_xyz[:, 0], aligned_est_xyz[:, 1], '.-', color='darkorange', linewidth=1.5, markersize=4, label='Aligned Estimated Trajectory', alpha=0.8)

            # Mark start and end points
            plt.scatter(gt_xyz_matched[0, 0], gt_xyz_matched[0, 1], marker='s', color='darkblue', s=100, label='GT Start', zorder=5)
            plt.scatter(aligned_est_xyz[0, 0], aligned_est_xyz[0, 1], marker='s', color='red', s=100, label='Est Start', zorder=5)
            plt.scatter(gt_xyz_matched[-1, 0], gt_xyz_matched[-1, 1], marker='*', color='darkblue', s=150, label='GT End', zorder=5)
            plt.scatter(aligned_est_xyz[-1, 0], aligned_est_xyz[-1, 1], marker='*', color='red', s=150, label='Est End', zorder=5)

            plt.xlabel("X Position (meters)")
            plt.ylabel("Y Position (meters)")
            plt.title(f"Ground Truth vs Estimated Trajectory (ATE RMSE: {ate_rmse:.4f}m)")
            plt.grid(True, linestyle='--', alpha=0.6)
            plt.axis('equal') # Ensure X, Y axis scales are consistent
            plt.legend(loc='best')
            plt.show()

            # (Optional) Plot error distance over time
            if len(common_timestamps) == aligned_est_xyz.shape[0]:
                errors_dist = np.linalg.norm(aligned_est_xyz - gt_xyz_matched, axis=1)
                plt.figure(figsize=(12, 4))
                plt.plot(common_timestamps, errors_dist, '-', color='red', linewidth=1.5, label='Error Distance')
                plt.xlabel("Timestamp (seconds)")
                plt.ylabel("Error Distance (meters)")
                plt.title("Absolute Trajectory Error (Distance) over Time")
                plt.grid(True, linestyle='--', alpha=0.6)
                plt.legend()
                plt.tight_layout()
                plt.show()
            else:
                print("Warning: Number of timestamps does not match number of matched points, cannot plot error over time.")

        else:
            print("Error: Insufficient associated points (<=1), cannot perform alignment and error calculation.")

    # Handle cases where ground truth loading failed or the estimated trajectory is empty
    elif not ground_truth_data:
        print("Skipping comparison due to failure to load Ground Truth data.")
    elif len(trajectory_xyz) <= 1:
        print("Skipping comparison due to insufficient calculated trajectory points (<=1).")

import numpy as np
import matplotlib.pyplot as plt
import os
from mpl_toolkits.mplot3d import Axes3D  # for 3D plotting

# --- Function: Load Ground Truth Poses ---
def load_ground_truth(gt_file):
    """Load ground truth file (format: timestamp tx ty tz qx qy qz qw)"""
    ground_truth = {}
    try:
        with open(gt_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                parts = line.split()
                if len(parts) >= 8:
                    ts  = float(parts[0])
                    xyz = np.array([float(p) for p in parts[1:4]])
                    ground_truth[ts] = {'xyz': xyz}
                else:
                    print(f"Skipping malformed ground truth line: {line}")
    except FileNotFoundError:
        print(f"!! Error: Ground truth file not found: {gt_file} !!")
        return None
    except Exception as e:
        print(f"!! Error reading ground truth file: {e} !!")
        return None

    if not ground_truth:
        print(f"Warning: No poses loaded from {os.path.basename(gt_file)}.")
    else:
        print(f"Loaded {len(ground_truth)} ground truth poses from {os.path.basename(gt_file)}.")
    return ground_truth

# --- Function: Associate Estimated Trajectory with Ground Truth ---
def associate_trajectory(estimated_xyz, estimated_timestamps, ground_truth_dict, max_diff_sec=0.02):
    """Associate estimated trajectory points with ground truth based on timestamps."""
    if (not ground_truth_dict or not estimated_timestamps or
        len(estimated_xyz) != len(estimated_timestamps)):
        print("Warning: Insufficient or mismatched input data for association.")
        return np.empty((0,3)), np.empty((0,3)), []

    gt_timestamps = np.array(sorted(ground_truth_dict.keys()))
    matches = []
    gt_search_idx = 0

    for i, est_ts in enumerate(estimated_timestamps):
        min_diff      = float('inf')
        best_gt_ts    = None
        # search around last match
        j = max(0, gt_search_idx - 5)
        while j < len(gt_timestamps):
            gt_ts = gt_timestamps[j]
            diff  = abs(est_ts - gt_ts)
            if diff < min_diff:
                min_diff   = diff
                best_gt_ts = gt_ts
            elif diff >= min_diff + max_diff_sec:
                break
            if gt_ts > est_ts + 2*max_diff_sec and min_diff > max_diff_sec:
                break
            j += 1

        if min_diff < max_diff_sec and best_gt_ts is not None:
            matches.append((
                est_ts,
                best_gt_ts,
                estimated_xyz[i],
                ground_truth_dict[best_gt_ts]['xyz']
            ))
            idxs = np.where(gt_timestamps == best_gt_ts)[0]
            if len(idxs) > 0:
                gt_search_idx = idxs[0]

    if not matches:
        print("Warning: No associations found. Check timestamps / max_diff_sec.")
        return np.empty((0,3)), np.empty((0,3)), []

    est_xyz_matched = np.array([m[2] for m in matches])
    gt_xyz_matched  = np.array([m[3] for m in matches])
    est_ts_matched  = [m[0] for m in matches]

    print(f"Associated {len(matches)} pose pairs.")
    return est_xyz_matched, gt_xyz_matched, est_ts_matched

# --- Function: Simple Translation Alignment ---
def align_translation(estimated_traj, ground_truth_traj):
    """Align estimated and ground truth by matching first point."""
    if estimated_traj.shape[0] == 0 or ground_truth_traj.shape[0] == 0:
        print("Warning: Empty trajectory, skipping alignment.")
        return estimated_traj
    offset = ground_truth_traj[0] - estimated_traj[0]
    aligned = estimated_traj + offset
    print(f"Applied translation offset: {offset}")
    return aligned

# --- Function: Calculate ATE RMSE ---
def calculate_ate_rmse(estimated_traj, ground_truth_traj):
    """Compute RMSE of absolute trajectory error."""
    if estimated_traj.shape != ground_truth_traj.shape:
        print(f"Shape mismatch: est {estimated_traj.shape}, gt {ground_truth_traj.shape}")
        n = min(estimated_traj.shape[0], ground_truth_traj.shape[0])
        if n == 0:
            return np.nan
        estimated_traj = estimated_traj[:n]
        ground_truth_traj = ground_truth_traj[:n]

    if estimated_traj.shape[0] == 0:
        print("Warning: No points to compute ATE.")
        return 0.0

    errors = np.linalg.norm(estimated_traj - ground_truth_traj, axis=1)
    rmse   = np.sqrt(np.mean(errors**2))
    return rmse

# === Main Comparison ===
print("\n--- 5. Start Comparison with Ground Truth ---")

# Preconditions: these should already exist in your workspace
#   trajectory_xyz: list or array of shape (N,3)
#   frame_associations: list of (timestamp_rgb, timestamp_depth, …)
#   TUM_DATASET_PATH: path to your dataset folder

if 'trajectory_xyz' not in locals():
    print("Error: 'trajectory_xyz' is undefined.")
elif 'frame_associations' not in locals():
    print("Error: 'frame_associations' is undefined.")
elif 'TUM_DATASET_PATH' not in locals() or not os.path.isdir(TUM_DATASET_PATH):
    print(f"Error: 'TUM_DATASET_PATH' ({TUM_DATASET_PATH}) invalid.")
else:
    # 1. Load GT
    gt_path = os.path.join(TUM_DATASET_PATH, 'groundtruth.txt')
    gt_data = load_ground_truth(gt_path)

    if gt_data and len(trajectory_xyz) > 1:
        # 2. Build timestamp list for estimates
        num_est = len(trajectory_xyz)
        assoc   = frame_associations
        if num_est > len(assoc):
            est_ts = [a[0] for a in assoc[:num_est]]
        else:
            est_ts = [assoc[k][0] for k in range(num_est)]
        est_xyz_np = np.array(trajectory_xyz)

        # 3. Associate
        est_xyz_matched, gt_xyz_matched, common_ts = associate_trajectory(
            est_xyz_np, est_ts, gt_data
        )

        if est_xyz_matched.shape[0] > 1:
            # 4. Align
            aligned_est = align_translation(est_xyz_matched, gt_xyz_matched)

            # 5. ATE RMSE
            ate_rmse = calculate_ate_rmse(aligned_est, gt_xyz_matched)
            print(f"\nATE RMSE: {ate_rmse:.4f} m")

            # ——— 2D XY Plot ———
            plt.figure(figsize=(9,7))
            plt.plot(gt_xyz_matched[:,0], gt_xyz_matched[:,1], '.-', label='GT (XY)', alpha=0.8)
            plt.plot(aligned_est[:,0],    aligned_est[:,1],    '.-', label='Est (XY)', alpha=0.8)
            plt.scatter(gt_xyz_matched[0,0], gt_xyz_matched[0,1], marker='s', label='GT Start')
            plt.scatter(aligned_est[0,0],    aligned_est[0,1],    marker='s', label='Est Start')
            plt.scatter(gt_xyz_matched[-1,0],gt_xyz_matched[-1,1],marker='*', label='GT End')
            plt.scatter(aligned_est[-1,0],   aligned_est[-1,1],   marker='*', label='Est End')
            plt.xlabel("X (m)"); plt.ylabel("Y (m)")
            plt.title(f"XY Trajectory (ATE RMSE = {ate_rmse:.4f} m)")
            plt.axis('equal'); plt.grid(True, linestyle='--', alpha=0.6)
            plt.legend(loc='best')
            plt.show()

            # ——— 3D Trajectory Plot ———
            fig = plt.figure(figsize=(10,8))
            ax  = fig.add_subplot(111, projection='3d')
            ax.plot(gt_xyz_matched[:,0], gt_xyz_matched[:,1], gt_xyz_matched[:,2],
                    '.-', label='Ground Truth', alpha=0.8)
            ax.plot(aligned_est[:,0],    aligned_est[:,1],    aligned_est[:,2],
                    '.-', label='Estimated',     alpha=0.8)
            ax.set_xlabel("X (m)"); ax.set_ylabel("Y (m)"); ax.set_zlabel("Z (m)")
            ax.set_title("3D Trajectory Comparison")
            ax.legend()
            plt.tight_layout()
            plt.show()

            # ——— Z vs Time Plot ———
            if len(common_ts) == aligned_est.shape[0]:
                plt.figure(figsize=(10,4))
                plt.plot(common_ts, gt_xyz_matched[:,2], '-', label='GT Z')
                plt.plot(common_ts, aligned_est[:,2],    '-', label='Est Z')
                plt.xlabel("Time (s)"); plt.ylabel("Z (m)")
                plt.title("Z‑Axis Position over Time")
                plt.grid(True, linestyle='--', alpha=0.6)
                plt.legend()
                plt.tight_layout()
                plt.show()
            else:
                print("Warning: timestamp count != matched points, skipping Z‑time plot.")
        else:
            print("Error: <=1 associated point, cannot align or compute error.")
    else:
        print("Skipping comparison: no ground truth or insufficient trajectory.")

"""# **Optional: For RPY Dataset Evaluation**"""

# -*- coding: utf-8 -*-
import numpy as np
import matplotlib.pyplot as plt
import os
import math
# Ensure scipy is imported for handling rotations and quaternions
try:
    from scipy.spatial.transform import Rotation as ScipyRotation
except ImportError:
    print("!! Error: Need to install the scipy library. Please run !pip install scipy !!")
    # Or raise an error as needed raise ImportError("scipy is required")

# --- Helper Function: Check if Rotation Matrix is valid ---
def isRotationMatrix(R):
    """ Checks if a matrix is a valid rotation matrix. """
    if R is None or R.shape != (3,3): return False
    # Check if it's close to orthogonal and has a determinant of +1
    Rt = np.transpose(R)
    shouldBeIdentity = np.dot(Rt, R)
    I = np.identity(3, dtype=R.dtype)
    n_ortho = np.linalg.norm(I - shouldBeIdentity)
    det = np.linalg.det(R)
    # Use a slightly looser threshold
    return n_ortho < 1e-4 and np.abs(det - 1.0) < 1e-4

# --- Helper Function: Convert Rotation Matrix to Euler Angles (RPY - ZYX convention) ---
def rotationMatrixToEulerAngles(R):
    """ Calculates Euler angles (roll, pitch, yaw) corresponding to a rotation matrix - ZYX order, returns radians """
    if not isRotationMatrix(R):
        # Return NaN for subsequent handling
        return np.array([np.nan, np.nan, np.nan])

    # sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])
    # singular = sy < 1e-6 # Check if close to gimbal lock

    # try:
    #     if not singular:
    #         x = math.atan2(R[2,1] , R[2,2]) # Roll
    #         y = math.atan2(-R[2,0], sy)      # Pitch
    #         z = math.atan2(R[1,0], R[0,0]) # Yaw
    #     else: # Gimbal lock case
    #         x = math.atan2(-R[1,2], R[1,1]) # Roll
    #         y = math.atan2(-R[2,0], sy)      # Pitch (+/- pi/2)
    #         z = 0                          # Yaw (set to 0)
    # except ValueError: # Defensive programming, handle potential atan2 domain errors
    #     return np.array([np.nan, np.nan, np.nan])

    [x,y,z] = ScipyRotation.from_matrix(R).as_euler('xyz', degrees = False)

    return np.array([x, y, z])

# --- Helper function to calculate inverse of SE(3) matrix ---
def inverse_se3(T):
    """ Calculate the inverse of the 4x4 SE(3) matrix """
    if T is None or T.shape != (4, 4): raise ValueError("Input must be a 4x4 matrix")
    R = T[0:3, 0:3]; t = T[0:3, 3]
    if not isRotationMatrix(R): print("Warning: Rotation part may be invalid when calculating SE(3) inverse.")
    R_inv = R.T; t_inv = -R_inv @ t
    T_inv = np.identity(4, dtype=T.dtype); T_inv[0:3, 0:3] = R_inv; T_inv[0:3, 3] = t_inv
    return T_inv

# --- Function to load ground truth poses (Timestamp, XYZ, Quaternion) ---
def load_ground_truth_poses(gt_file):
    """Load ground truth file (timestamp tx ty tz qx qy qz qw)"""
    ground_truth_poses = {}; line_count = 0; parsed_count = 0
    try:
        with open(gt_file, 'r') as f:
            for line in f:
                line_count += 1; line = line.strip()
                if not line or line.startswith('#'): continue
                parts = line.split()
                if len(parts) == 8:
                    try:
                        ts=float(parts[0]); xyz=np.array([float(p) for p in parts[1:4]]); quat_xyzw=np.array([float(p) for p in parts[4:8]])
                        # Check if quaternion is valid (non-zero)
                        if not np.isclose(np.linalg.norm(quat_xyzw), 0):
                            ground_truth_poses[ts] = {'xyz': xyz, 'quat_xyzw': quat_xyzw}; parsed_count += 1
                        else: print(f"Warning: GT line {line_count} quaternion is close to zero, skipping.")
                    except ValueError: print(f"Warning: Unable to parse GT line {line_count}")
                else: print(f"Warning: Skipping malformed GT line {line_count}")
    except FileNotFoundError: print(f"!! Error: GT file not found: {gt_file} !!"); return None
    except Exception as e: print(f"!! Error: Error reading GT file '{gt_file}': {e} !!"); return None
    if parsed_count == 0: print(f"Warning: Failed to load any valid GT poses from {os.path.basename(gt_file)}.")
    else: print(f"Loaded {parsed_count} GT poses from {os.path.basename(gt_file)}.")
    return ground_truth_poses

# --- Function to associate estimated poses with ground truth ---
def associate_poses(estimated_poses_T_world_cam, estimated_timestamps, ground_truth_poses_dict, max_diff_sec=0.02):
    """Associate estimated poses (4x4 matrices) and ground truth poses based on timestamps."""
    if not ground_truth_poses_dict or not estimated_timestamps or len(estimated_poses_T_world_cam) != len(estimated_timestamps): print("Warning: Insufficient or mismatched pose association input."); return []
    gt_timestamps = np.array(sorted(ground_truth_poses_dict.keys())); matches = []; gt_search_idx = 0
    for i, est_ts in enumerate(estimated_timestamps):
        min_diff = float('inf'); best_match_gt_ts = -1
        search_start = max(0, gt_search_idx - 10); j = search_start
        while j < len(gt_timestamps):
            gt_ts = gt_timestamps[j]; diff = abs(est_ts - gt_ts)
            if diff < min_diff: min_diff = diff; best_match_gt_ts = gt_ts
            elif diff >= min_diff + max_diff_sec and min_diff < max_diff_sec : break
            if gt_ts > est_ts + max_diff_sec * 5 and min_diff > max_diff_sec: break
            j += 1
        if min_diff < max_diff_sec and best_match_gt_ts != -1:
            if best_match_gt_ts in ground_truth_poses_dict:
                matches.append((est_ts, best_match_gt_ts, estimated_poses_T_world_cam[i], ground_truth_poses_dict[best_match_gt_ts]))
                gt_match_indices = np.where(gt_timestamps == best_match_gt_ts)[0]
                if len(gt_match_indices) > 0: gt_search_idx = gt_match_indices[0]
    if not matches: print("Warning: Failed to associate any estimated poses with GT.")
    else: print(f"Successfully associated {len(matches)} pairs of estimated and GT poses.")
    return matches

# --- Function to calculate angular difference between two rotation matrices ---
def rotation_angular_difference(R1, R2):
    """Calculate the rotation angle (radians) corresponding to R1 * R2.T"""
    if not isRotationMatrix(R1) or not isRotationMatrix(R2): return np.nan
    try:
        R_diff = R1 @ R2.T; trace = np.trace(R_diff)
        clipped_trace_term = np.clip((trace - 1.0) / 2.0, -1.0, 1.0)
        angle_rad = np.arccos(clipped_trace_term)
    except Exception as e: print(f"Warning: Error calculating angle difference: {e}"); return np.nan
    return angle_rad

# --- Function for SE(3) Alignment using SVD ---
def align_poses_se3(estimated_xyz, ground_truth_xyz):
    """Calculate the optimal SE(3) alignment transformation using SVD (assuming scale is 1)"""
    if estimated_xyz.shape != ground_truth_xyz.shape or estimated_xyz.shape[0] < 3: print("Warning: Insufficient points or shape mismatch for SE(3) alignment."); return None
    centroid_est = np.mean(estimated_xyz,axis=0); centroid_gt = np.mean(ground_truth_xyz,axis=0)
    centered_est = estimated_xyz - centroid_est; centered_gt = ground_truth_xyz - centroid_gt
    H = centered_est.T @ centered_gt
    try: U, S, Vt = np.linalg.svd(H)
    except np.linalg.LinAlgError: print("Warning: SVD calculation failed."); return None
    R_align = Vt.T @ U.T
    if np.linalg.det(R_align) < 0: Vt[2, :] *= -1; R_align = Vt.T @ U.T
    if not isRotationMatrix(R_align): print("Warning: Calculated R_align is invalid."); return None
    t_align = centroid_gt - R_align @ centroid_est
    T_gt_est = np.identity(4); T_gt_est[0:3,0:3] = R_align; T_gt_est[0:3,3] = t_align
    print("SE(3) alignment calculation complete.")
    return T_gt_est


# --- Main RPY Comparison Logic (SE(3) Align + Center + Correct P/Y Sign + Unwrap Roll) ---
print("\n--- 6. Start RPY Orientation Comparison Evaluation (SE(3) Align, Plot Centering/Correction/Roll Unwrapping) ---")

# --- Pre-checks ---
error_occurred = False
# Check if dependent variables exist and have the correct type
if 'TUM_DATASET_PATH' not in locals() or not isinstance(locals().get('TUM_DATASET_PATH'), str) or not os.path.isdir(TUM_DATASET_PATH):
    print(f"!! Error: 'TUM_DATASET_PATH' ({locals().get('TUM_DATASET_PATH', 'undefined')}) is invalid or not defined. !!"); error_occurred = True
elif 'rpy' not in locals().get('TUM_DATASET_PATH','').lower(): # Check if it's an RPY sequence (lowercase comparison)
    print(f"!! Warning: Current dataset path '{TUM_DATASET_PATH}' might not be an RPY sequence, please confirm! !!")

if 'absolute_poses_T_world_cam' not in locals() or not isinstance(absolute_poses_T_world_cam, list):
    print("!! Error: Variable 'absolute_poses_T_world_cam' is not a list or is undefined. !!"); error_occurred = True
elif len(absolute_poses_T_world_cam) <= 1:
    print("!! Error: Insufficient data in 'absolute_poses_T_world_cam' (<=1). !!"); error_occurred = True

if 'frame_associations' not in locals() or not isinstance(frame_associations, list):
    print("!! Error: Variable 'frame_associations' is not a list or is undefined. !!"); error_occurred = True
elif len(frame_associations) == 0:
    print("!! Error: 'frame_associations' list is empty. !!"); error_occurred = True

# --- Continue only if basic checks pass ---
if not error_occurred:
    # 1. Load Ground Truth Data
    gt_file_path = os.path.join(TUM_DATASET_PATH, 'groundtruth.txt')
    ground_truth_poses_data = load_ground_truth_poses(gt_file_path)

    if ground_truth_poses_data and len(absolute_poses_T_world_cam) > 1:
        # 2. Get timestamps of estimated poses
        num_est_poses = len(absolute_poses_T_world_cam)
        # Ensure timestamp count matches pose count
        if num_est_poses > len(frame_associations):
            print(f"Warning: Number of poses ({num_est_poses}) > number of frame associations ({len(frame_associations)}), truncating pose list.")
            absolute_poses_T_world_cam = absolute_poses_T_world_cam[:len(frame_associations)]
            num_est_poses = len(absolute_poses_T_world_cam)
        estimated_timestamps = [frame_associations[k][0] for k in range(num_est_poses)] if num_est_poses > 0 else []

        # 3. Associate poses
        matched_poses = []
        if estimated_timestamps:
            matched_poses = associate_poses(
                absolute_poses_T_world_cam,
                estimated_timestamps,
                ground_truth_poses_data
            )

        # Need at least 3 matching points for SE(3) alignment
        if len(matched_poses) >= 3:

            # Extract XYZ coordinates for alignment
            est_xyz_matched = np.array([m[2][0:3, 3] for m in matched_poses])
            gt_xyz_matched = np.array([m[3]['xyz'] for m in matched_poses])

            # 4. Calculate SE(3) alignment transformation
            T_gt_est = align_poses_se3(est_xyz_matched, gt_xyz_matched)

            if T_gt_est is not None: # Ensure alignment was successful
                # 5. Apply alignment, calculate errors and RPY
                angular_errors_rad_aligned = []
                aligned_est_rpy_deg_list = []
                gt_rpy_deg_list = []
                common_timestamps_list = []

                print("Calculating aligned errors and RPY...")
                for est_ts, gt_ts, est_pose_T_world_est, gt_pose_dict in matched_poses:
                    try:
                        T_world_est_aligned = T_gt_est @ est_pose_T_world_est
                        R_est_aligned = T_world_est_aligned[0:3, 0:3]
                        gt_quat_i = gt_pose_dict['quat_xyzw']
                        if np.isclose(np.linalg.norm(gt_quat_i), 0): continue
                        R_gt_i = ScipyRotation.from_quat(gt_quat_i).as_matrix()

                        # Calculate angular error
                        angle_diff_rad = rotation_angular_difference(R_est_aligned, R_gt_i)
                        if np.isnan(angle_diff_rad): continue
                        angular_errors_rad_aligned.append(angle_diff_rad)

                        # Convert RPY
                        est_rpy_aligned = rotationMatrixToEulerAngles(R_est_aligned)
                        gt_rpy = rotationMatrixToEulerAngles(R_gt_i)
                        if np.isnan(est_rpy_aligned).any() or np.isnan(gt_rpy).any(): continue

                        aligned_est_rpy_deg_list.append(np.degrees(est_rpy_aligned))
                        gt_rpy_deg_list.append(np.degrees(gt_rpy))
                        common_timestamps_list.append(gt_ts)

                    except Exception as e:
                        print(f"Warning: Error processing pose pair (est_ts={est_ts}, gt_ts={gt_ts}): {e}.")
                        continue

                # --- Post-processing for plotting ---
                if common_timestamps_list: # Ensure data was collected
                    aligned_est_rpy_deg_np = np.array(aligned_est_rpy_deg_list)
                    gt_rpy_deg_np = np.array(gt_rpy_deg_list)
                    common_timestamps_np = np.array(common_timestamps_list)

                    # --- 5a. Center RPY ---
                    print("DEBUG: Centering RPY for plotting...")
                    rpy_est_plot = aligned_est_rpy_deg_np - aligned_est_rpy_deg_np[0, :]
                    rpy_gt_plot = gt_rpy_deg_np - gt_rpy_deg_np[0, :]

                    # --- 5b. Sign Correction (Pitch & Yaw) ---
                    print("DEBUG: Correcting estimated Pitch/Yaw sign for plotting...")
                    rpy_est_plot_corrected = rpy_est_plot.copy()
                    rpy_est_plot_corrected[:, 1] *= 1.0 # Pitch
                    rpy_est_plot_corrected[:, 2] *= 1.0 # Yaw

                    # --- 5c. Unwrap Roll ---
                    print("DEBUG: Unwrapping Roll angle for plotting...")
                    # !! Use the centered Roll data for unwrapping !!
                    roll_gt_unwrapped_deg = np.degrees(np.unwrap(np.radians(rpy_gt_plot[:, 0])))
                    roll_est_unwrapped_deg = np.degrees(np.unwrap(np.radians(rpy_est_plot[:, 0]))) # Use the uncorrected Roll

                    # --- 6. Calculate Quantitative Error (RMSE) ---
                    if angular_errors_rad_aligned:
                        ate_rot_rmse_rad_aligned = np.sqrt(np.mean(np.square(np.array(angular_errors_rad_aligned))))
                        ate_rot_rmse_deg_aligned = np.degrees(ate_rot_rmse_rad_aligned)
                        print("\nSE(3) Aligned Orientation Comparison Results:")
                        print(f"Rotation Absolute Trajectory Error (Rotation ATE) RMSE: {ate_rot_rmse_deg_aligned:.4f} degrees")
                    else:
                        ate_rot_rmse_deg_aligned = np.nan
                        print("\nUnable to calculate valid angular error RMSE.")

                    # --- 7. Visualize Comparison ---
                    print("Plotting centered, Pitch/Yaw corrected, and Roll unwrapped orientation comparison...")
                    if len(common_timestamps_np) == rpy_est_plot_corrected.shape[0] == rpy_gt_plot.shape[0] and len(common_timestamps_np) > 0:
                        plt.style.use('seaborn-v0_8-whitegrid')
                        fig, axs = plt.subplots(3, 1, figsize=(12, 9), sharex=True)
                        titles = ['Roll (relative, unwrapped)', 'Pitch (relative)', 'Yaw (relative)']
                        colors_est = ['darkorange', 'purple', 'green']
                        colors_gt = ['blue', 'magenta', 'darkcyan']

                        # Plot Roll (unwrapped)
                        axs[0].plot(common_timestamps_np, roll_gt_unwrapped_deg, '--', color=colors_gt[0], linewidth=1.5, label=f'GT {titles[0]}')
                        axs[0].plot(common_timestamps_np, roll_est_unwrapped_deg, '-', color=colors_est[0], linewidth=1.5, label=f'Est {titles[0]}')
                        axs[0].set_ylabel('Relative Angle (°)')
                        axs[0].set_title(titles[0])
                        axs[0].grid(True, linestyle='--', alpha=0.6); axs[0].legend()

                        # Plot Pitch and Yaw (centered + sign corrected)
                        for i in range(1, 3):
                            axs[i].plot(common_timestamps_np, rpy_gt_plot[:, i], '--', color=colors_gt[i], linewidth=1.5, label=f'GT {titles[i]}')
                            axs[i].plot(common_timestamps_np, rpy_est_plot_corrected[:, i], '-', color=colors_est[i], linewidth=1.5, label=f'Corrected Est. {titles[i]}')
                            axs[i].set_ylabel('Relative Angle (°)')
                            axs[i].set_title(titles[i])
                            axs[i].grid(True, linestyle='--', alpha=0.6); axs[i].legend()

                        axs[2].set_xlabel("Timestamp (seconds)")
                        fig.suptitle("Relative Orientation (RPY) vs Ground Truth\n(Centered, Est. P/Y Corrected, Roll Unwrapped for Plot)", fontsize=14)
                        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
                        plt.show()

                        # Plot total angular error
                        if angular_errors_rad_aligned:
                            plt.figure(figsize=(12, 4))
                            plt.plot(common_timestamps_np, np.degrees(np.array(angular_errors_rad_aligned)), '-', color='red', linewidth=1.5, label='Total Angular Error (Aligned)')
                            plt.xlabel("Timestamp (seconds)"); plt.ylabel("Angular Error (°)")
                            plt.title(f"Total Angular Orientation Error Over Time (SE(3) Aligned, RMSE: {ate_rot_rmse_deg_aligned:.2f}°)")
                            plt.grid(True, linestyle='--', alpha=0.6); plt.legend(); plt.tight_layout(); plt.show()
                        else:
                            print("Error: Data lengths are inconsistent or empty for plotting.")
                    else:
                        print("Error: Failed to collect valid RPY data for post-processing and plotting.")

                elif len(matched_poses) < 3:
                    print("Error: Insufficient number of associated poses (<3), cannot perform SE(3) alignment and comparison.")
                else: # matched_poses is empty
                    print("Error: No pose pairs were associated.")

        elif not ground_truth_poses_data:
            print("Skipping orientation comparison due to failure to load Ground Truth data.")
        # Other initial checks handled by outer 'if'

# Final message if initial checks failed
if error_occurred:
    print("\nEvaluation code was not executed due to pre-check errors.")